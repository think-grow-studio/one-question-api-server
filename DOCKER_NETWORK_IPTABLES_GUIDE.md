# Docker 컨테이너 네트워크와 iptables 완벽 가이드

## 1. 기본 개념: 네트워크 트래픽의 3가지 유형

컴퓨터(VM)를 기준으로 네트워크 트래픽은 3가지로 나뉩니다.

```
                    ┌─────────────────────┐
                    │                     │
   외부에서 들어옴   │        VM          │   VM에서 외부로 나감
   ─────────────▶  │    (내 서버)        │  ──────────────▶
     INPUT         │                     │      OUTPUT
                    │                     │
                    └─────────────────────┘
```

### INPUT (인바운드)
- **방향**: 외부 → VM 자체
- **예시**: 누군가 내 서버에 SSH 접속, 웹사이트 접속
- **제어**: "누가 내 서버에 접근할 수 있나?"

### OUTPUT (아웃바운드)
- **방향**: VM 자체 → 외부
- **예시**: 서버에서 apt update 실행, 서버에서 외부 API 호출
- **제어**: "내 서버가 어디에 접근할 수 있나?"

### FORWARD (포워드) ⭐ 핵심!
- **방향**: 외부 → VM을 **거쳐서** → 다른 곳으로
- **예시**: VM이 라우터처럼 트래픽을 중계
- **제어**: "내 서버를 경유하는 트래픽을 허용할까?"

```
    외부 A                    VM                     외부 B
   ─────────▶  들어와서  ─────────▶  나가서  ─────────▶
              (INPUT X)   FORWARD   (OUTPUT X)

   * VM 자체가 목적지가 아니라 "경유지"일 때 FORWARD 적용
```

---

## 2. Docker 컨테이너는 왜 특별한가?

### 컨테이너 = 별도의 네트워크 공간

Docker 컨테이너는 VM 안에 있지만, **별도의 가상 네트워크**를 가집니다.

```
┌──────────────────────────────────────────────────────────┐
│                        VM                                │
│                   IP: 10.0.0.5                          │
│                                                          │
│    ┌────────────────┐      ┌────────────────┐           │
│    │   컨테이너 A    │      │   컨테이너 B    │           │
│    │  172.17.0.2    │      │  172.17.0.3    │           │
│    └───────┬────────┘      └───────┬────────┘           │
│            │                       │                     │
│            └───────────┬───────────┘                     │
│                        │                                 │
│                ┌───────┴───────┐                        │
│                │  docker0 브릿지 │                        │
│                │  172.17.0.1   │                        │
│                └───────┬───────┘                        │
│                        │                                 │
│    ────────────────────┴─────────────────────────────   │
│                    VM 네트워크                           │
└──────────────────────────────────────────────────────────┘
                         │
                         ▼
                    외부 인터넷
```

### 핵심 포인트

| 구분 | IP 대역 | 네트워크 |
|------|---------|----------|
| VM 자체 | 10.0.0.x | Oracle Cloud VCN |
| 컨테이너 | 172.17.0.x | Docker 내부 네트워크 |

**컨테이너(172.17.0.x)와 외부 인터넷은 서로 다른 네트워크!**

---

## 3. 컨테이너가 외부와 통신할 때 무슨 일이 일어나나?

### VM에서 직접 외부 접속 (OUTPUT)

```
[ VM 프로세스 ]
      │
      │  "nslookup google.com"
      ▼
  OUTPUT chain ──▶ 허용됨 ✅
      │
      ▼
  [ 외부 DNS 서버 ]
```

VM 자체가 보내는 트래픽 → **OUTPUT chain** → 대부분 허용

### 컨테이너에서 외부 접속 (FORWARD) ⭐

```
[ 컨테이너 172.17.0.2 ]
      │
      │  "DNS 요청"
      ▼
[ docker0 브릿지 172.17.0.1 ]
      │
      │  "172.17.0.x → 외부"는 VM 입장에서 "경유 트래픽"
      ▼
  FORWARD chain ──▶ ???
      │
      ▼
  [ 외부 DNS 서버 ]
```

컨테이너가 보내는 트래픽 → **FORWARD chain** → 여기가 문제!

### 왜 FORWARD인가?

```
컨테이너 IP: 172.17.0.2  (Docker 네트워크)
VM IP:       10.0.0.5    (Oracle Cloud 네트워크)
DNS 서버:    169.254.169.254 (외부)
```

- 트래픽 출발지(172.17.0.2)도 VM 자체가 아님
- 트래픽 목적지(169.254.169.254)도 VM 자체가 아님
- **VM은 그냥 중간에서 전달만 해주는 역할** = FORWARD

---

## 4. iptables 규칙은 어떻게 작동하나?

### 규칙 처리 순서: 위에서 아래로, 먼저 매칭되면 끝!

```
패킷 도착
    │
    ▼
┌─────────────────┐
│    규칙 1       │ ──▶ 매칭 안 됨 ──▶ 다음으로
└─────────────────┘
    │
    ▼
┌─────────────────┐
│    규칙 2       │ ──▶ 매칭 안 됨 ──▶ 다음으로
└─────────────────┘
    │
    ▼
┌─────────────────┐
│    규칙 3       │ ──▶ 매칭됨! ACCEPT ──▶ 통과 ✅ (여기서 끝)
└─────────────────┘
    │
    ▼
┌─────────────────┐
│    규칙 4       │ ──▶ 실행 안 됨 (위에서 이미 결정됨)
└─────────────────┘
```

### 중요: 순서가 전부!

```
# 시나리오 A: ACCEPT가 먼저
규칙 1: ACCEPT  ──▶ 허용됨 ✅
규칙 2: REJECT  ──▶ 실행 안 됨

# 시나리오 B: REJECT가 먼저
규칙 1: REJECT  ──▶ 차단됨 🚫
규칙 2: ACCEPT  ──▶ 실행 안 됨
```

**같은 규칙이라도 순서에 따라 결과가 완전히 달라짐!**

---

## 5. 문제 상황 분석

### one-question-sub VM의 FORWARD chain

```
┌─────────────────────────────────────────────────────────────────┐
│  순서  │  규칙                        │  역할                    │
├─────────────────────────────────────────────────────────────────┤
│   1   │  DOCKER-USER                 │  사용자 정의 (기본: 넘김) │
│   2   │  ACCEPT (ESTABLISHED)        │  기존 연결만 허용        │
│   3   │  DOCKER-ISOLATION-STAGE-1    │  Docker 네트워크 격리    │
│   4   │  DOCKER                      │  외부→컨테이너 포트매핑   │
│   5   │  REJECT  ← 🚫 문제!          │  나머지 전부 차단        │
│   6   │  ACCEPT  ← 😢 무의미         │  전부 허용 (실행 안 됨)  │
└─────────────────────────────────────────────────────────────────┘
```

### DNS 요청이 각 규칙을 통과하는 과정

```
[ 컨테이너 ] ──▶ DNS 요청 (169.254.169.254로)
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 규칙 1: DOCKER-USER                                              │
│                                                                  │
│ Q: 사용자가 정의한 특별한 규칙이 있나?                             │
│ A: 없음 (기본값 RETURN = 다음으로 넘김)                           │
│                                                                  │
│ 결과: 다음 규칙으로 ▼                                             │
└──────────────────────────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 규칙 2: ACCEPT (ctstate RELATED,ESTABLISHED)                     │
│                                                                  │
│ Q: 이미 연결된 세션의 패킷인가?                                    │
│ A: 아니오. DNS 요청은 "새로운 연결"임                              │
│                                                                  │
│ 💡 ESTABLISHED = 이미 연결됨 (예: 악수 끝난 상태)                  │
│ 💡 NEW = 새로운 연결 시도 (예: 처음 악수하려는 상태)                │
│                                                                  │
│ 결과: 해당 안 됨, 다음 규칙으로 ▼                                  │
└──────────────────────────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 규칙 3: DOCKER-ISOLATION-STAGE-1                                 │
│                                                                  │
│ Q: 다른 Docker 네트워크로 가는 트래픽인가?                         │
│ A: 아니오. 외부(169.254.169.254)로 가는 트래픽임                   │
│                                                                  │
│ 💡 이 규칙은 network-A ↔ network-B 간 격리용                      │
│                                                                  │
│ 결과: 해당 안 됨, 다음 규칙으로 ▼                                  │
└──────────────────────────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 규칙 4: DOCKER (외부→컨테이너 포트매핑)                            │
│                                                                  │
│ Q: 외부에서 컨테이너로 들어오는 트래픽인가?                         │
│ A: 아니오. 컨테이너에서 외부로 "나가는" 트래픽임                    │
│                                                                  │
│ 💡 이 규칙은 "-p 8080:8080" 같은 포트 매핑 처리용                  │
│ 💡 외부 → 컨테이너 방향만 처리                                     │
│                                                                  │
│ 결과: 해당 안 됨, 다음 규칙으로 ▼                                  │
└──────────────────────────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 규칙 5: REJECT  🚫🚫🚫                                            │
│                                                                  │
│ Q: 여기까지 온 모든 트래픽                                        │
│ A: 전부 차단! "icmp-host-prohibited" 응답 보냄                    │
│                                                                  │
│ 결과: 차단됨! 🚫                                                   │
│                                                                  │
│ ──────────────────────────────────────────────────────────────── │
│ DNS 요청 실패 → "Unknown host" 에러 → DB 연결 실패                │
└──────────────────────────────────────────────────────────────────┘
                     │
                     ✖ (여기서 끝, 규칙 6은 실행 안 됨)

┌──────────────────────────────────────────────────────────────────┐
│ 규칙 6: ACCEPT (전부 허용)                                        │
│                                                                  │
│ 😢 이 규칙은 영원히 실행되지 않음                                  │
│    (규칙 5에서 이미 모든 트래픽이 REJECT됨)                        │
└──────────────────────────────────────────────────────────────────┘
```

---

## 6. 왜 다른 VM(pray-together-api)은 됐나?

### pray-together-api VM의 FORWARD chain

```
┌─────────────────────────────────────────────────────────────────┐
│  순서  │  규칙                        │  역할                    │
├─────────────────────────────────────────────────────────────────┤
│   1   │  DOCKER-USER                 │  사용자 정의             │
│   2   │  DOCKER-ISOLATION-STAGE-1    │  Docker 네트워크 격리    │
│   3   │  ACCEPT (ESTABLISHED)        │  기존 연결 허용          │
│   4   │  DOCKER                      │  포트매핑                │
│   5   │  ACCEPT  ← ✅ 여기서 허용!   │  전부 허용               │
│   6   │  ACCEPT                      │  전부 허용               │
│   7   │  REJECT                      │  차단 (실행 안 됨)       │
└─────────────────────────────────────────────────────────────────┘
```

**REJECT 전에 ACCEPT가 있어서 컨테이너 트래픽이 허용됨!**

### 두 VM의 차이

```
one-question-sub:     ... → REJECT → ACCEPT (잘못된 순서)
pray-together-api:    ... → ACCEPT → ACCEPT → REJECT (올바른 순서)
```

---

## 7. 해결 방법

### REJECT 앞에 Docker 트래픽 허용 규칙 추가

```bash
# docker0 인터페이스에서 들어오는 트래픽 허용 (컨테이너 → 외부)
sudo iptables -I FORWARD 5 -i docker0 -j ACCEPT

# docker0 인터페이스로 나가는 트래픽 허용 (외부 → 컨테이너)
sudo iptables -I FORWARD 6 -o docker0 -j ACCEPT

# 영구 저장
sudo netfilter-persistent save
```

### 옵션 설명

| 옵션 | 의미 |
|------|------|
| `-I FORWARD 5` | FORWARD chain의 5번째 위치에 삽입 |
| `-i docker0` | 입력 인터페이스가 docker0인 경우 |
| `-o docker0` | 출력 인터페이스가 docker0인 경우 |
| `-j ACCEPT` | 허용 |

### 수정 후 규칙 순서

```
┌─────────────────────────────────────────────────────────────────┐
│  순서  │  규칙                        │  역할                    │
├─────────────────────────────────────────────────────────────────┤
│   1   │  DOCKER-USER                 │  사용자 정의             │
│   2   │  ACCEPT (ESTABLISHED)        │  기존 연결 허용          │
│   3   │  DOCKER-ISOLATION-STAGE-1    │  격리                   │
│   4   │  DOCKER                      │  포트매핑                │
│   5   │  ACCEPT -i docker0  ← ✅ 새로 추가                      │
│   6   │  ACCEPT -o docker0  ← ✅ 새로 추가                      │
│   7   │  REJECT                      │  차단                   │
│   8   │  ACCEPT                      │  (실행 안 됨)           │
└─────────────────────────────────────────────────────────────────┘
```

### 수정 후 DNS 요청 흐름

```
[ 컨테이너 ] ──▶ DNS 요청
       │
       ▼
  규칙 1~4: 해당 안 됨, 통과
       │
       ▼
  규칙 5: ACCEPT -i docker0
       │
       │  Q: docker0에서 들어온 트래픽인가?
       │  A: 예! (컨테이너 → docker0 → 외부)
       │
       ▼
  ACCEPT! ✅
       │
       ▼
  [ DNS 서버 ] ──▶ 응답 ──▶ [ 컨테이너 ]
       │
       ▼
  Oracle DB 연결 성공! 🎉
```

---

## 8. 핵심 요약

| 항목 | 내용 |
|------|------|
| **증상** | Docker 컨테이너에서 외부 연결 실패 (DNS, DB) |
| **원인** | iptables FORWARD chain에서 REJECT가 ACCEPT보다 먼저 실행됨 |
| **이유** | Oracle Cloud 기본 보안 정책이 경유 트래픽을 차단 |
| **해결** | REJECT 앞에 docker0 트래픽 허용 규칙 추가 |

### 기억할 것

1. **Docker 컨테이너 트래픽 = FORWARD chain** (INPUT/OUTPUT 아님)
2. **iptables는 순서가 전부** (먼저 매칭되면 끝)
3. **REJECT가 ACCEPT보다 앞에 있으면 의미 없음**

---

## 9. 추가 정보: Oracle Cloud 내부 DNS

Oracle Cloud는 `169.254.169.254`라는 내부 DNS 서버를 제공합니다.

### 특징
- VCN 내부 인스턴스 이름 해석
- 외부 도메인 해석 (recursive DNS)
- Oracle Cloud 서비스 (ADB 등) 이름 해석에 최적화

### 주의사항
Docker 컨테이너에서 `--dns 8.8.8.8` 같이 외부 DNS를 명시적으로 지정하면,
Oracle Cloud의 iptables 정책에 의해 차단될 수 있습니다.

**권장**: DNS 설정을 명시하지 않고 호스트의 DNS 설정을 상속받도록 함

---

## 10. 디버깅 명령어 모음

```bash
# iptables FORWARD chain 확인
sudo iptables -L FORWARD -n --line-numbers

# Docker 컨테이너 DNS 설정 확인
docker inspect <container_name> --format '{{.HostConfig.Dns}}'

# 컨테이너 내부 resolv.conf 확인
docker exec <container_name> cat /etc/resolv.conf

# 컨테이너 내부에서 DNS 테스트
docker exec <container_name> getent hosts google.com

# VM에서 특정 DNS 서버로 쿼리 테스트
nslookup google.com 169.254.169.254
```
